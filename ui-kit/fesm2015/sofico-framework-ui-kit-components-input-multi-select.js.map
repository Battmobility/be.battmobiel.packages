{"version":3,"file":"sofico-framework-ui-kit-components-input-multi-select.js","sources":["../../../../projects/sofico-framework/ui-kit/components/input-multi-select/input-multi-select.component.ts","../../../../projects/sofico-framework/ui-kit/components/input-multi-select/input-multi-select.module.ts","../../../../projects/sofico-framework/ui-kit/components/input-multi-select/sofico-framework-ui-kit-components-input-multi-select.ts"],"sourcesContent":["import {\n  ChangeDetectorRef,\n  Component,\n  ElementRef,\n  EventEmitter,\n  Host,\n  Input,\n  OnChanges,\n  OnDestroy,\n  OnInit,\n  Optional,\n  Output,\n  ViewChild,\n  ViewEncapsulation\n} from '@angular/core';\nimport { ControlValueAccessor, FormControl, NgControl } from '@angular/forms';\nimport { FormComponent } from '@sofico-framework/ui-kit/components/form';\nimport {\n  OnSofFocus,\n  SOF_FOCUS_COMPONENT\n} from '@sofico-framework/ui-kit/directives/focus';\nimport { SearchFnSelect, SearchOption } from '@sofico-framework/ui-kit/types';\nimport {\n  NzFilterOptionType,\n  NzSelectItemInterface,\n  NzSelectSizeType\n} from 'ng-zorro-antd/select';\nimport { Changes, takeUntilDestroy, UntilDestroy } from 'ngx-reactivetoolkit';\nimport { Observable } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\n@UntilDestroy()\n@Component({\n  selector: 'sof-input-multi-select',\n  styleUrls: ['./input-multi-select.component.scss'],\n  encapsulation: ViewEncapsulation.None,\n  template: `\n    <div class=\"multi-select\">\n      <nz-select\n        #inputElement\n        [@.disabled]=\"true\"\n        [formControl]=\"internalFormControl\"\n        [nzOptions]=\"formattedOptions$ | async\"\n        nzMode=\"multiple\"\n        [nzSize]=\"size\"\n        [nzShowArrow]=\"true\"\n        [nzShowSearch]=\"showSearch\"\n        [nzAllowClear]=\"clearable\"\n        [nzBorderless]=\"borderless\"\n        [nzDisabled]=\"isDisabled\"\n        [nzFilterOption]=\"nzSearchFn\"\n        [nzPlaceHolder]=\"placeholder\"\n        [nzNotFoundContent]=\"tc + notFoundContent | translate\"\n        [nzTokenSeparators]=\"tokenSeparators\"\n        [nzMaxTagCount]=\"maxTagCount\"\n        [class.is-invalid]=\"\n          invalid ||\n          (ngControl?.invalid && (ngControl?.touched || form?.submitted))\n        \"\n        (nzBlur)=\"onTouch()\"\n      ></nz-select>\n    </div>\n  `,\n  providers: [\n    { provide: SOF_FOCUS_COMPONENT, useExisting: InputMultiSelectComponent }\n  ]\n})\nexport class InputMultiSelectComponent\n  implements ControlValueAccessor, OnChanges, OnInit, OnDestroy, OnSofFocus {\n  constructor(\n    @Optional() public form: FormComponent,\n    @Optional() @Host() public ngControl: NgControl,\n    private changeDetectorRef: ChangeDetectorRef\n  ) {\n    if (ngControl) {\n      ngControl.valueAccessor = this;\n    }\n  }\n\n  @Input() tc: string;\n\n  // Size of Select input\n  @Input() size: NzSelectSizeType = 'large';\n\n  // Whether to show the search icon\n  @Input() showSearch = true;\n\n  // Whether to show the clear button icon\n  @Input() clearable = true;\n\n  // Whether the select has borderless styling\n  @Input() borderless = false;\n\n  // Specify content to show when no result matches..\n  @Input() notFoundContent = '.NOT-FOUND';\n\n  // The placeholder of the input.\n  @Input() placeholder = '';\n\n  // Separator used to tokenize on tag/multiple mode\n  @Input() tokenSeparators = [','];\n\n  // TODO remove or keep, if keep what default value do we use\n  //  Max selected option can be selected\n  @Input() maxMultipleCount: number;\n\n  // Max tag count to show\n  @Input() maxTagCount = 5;\n\n  /**\n   * The id of the input to connect to a label tag.\n   * currently not supported\n   */\n  @Input() labelForId: string;\n\n  /**\n   *  Determines if the input is disabled.\n   */\n  @Input() isDisabled: boolean;\n\n  /**\n   * The options that populate the list.\n   */\n  @Input() options: any[];\n\n  /**\n   * Determines which property that must be used as list label.\n   */\n  @Input() selectorLabel: (x: any) => any;\n\n  /**\n   * Determines which property that must be used as list value.\n   */\n  @Input() selectorValue: (x: any) => any;\n\n  /**\n   * Determines which property that must be used as option disable.\n   */\n  @Input() selectorDisabled: (x: any) => any;\n\n  /**\n   * Determines whether the input is in a valid state.\n   */\n  @Input() invalid: boolean;\n\n  /**\n   * EventEmitter that will emit the value when changed.\n   */\n  @Output() changeValue = new EventEmitter<any>();\n\n  // Form control used instead in simple value, as the ng-select component has internal implementation we can't reach.\n  // By making use of a form control internally we have all the features available.\n  internalFormControl = new FormControl([]);\n  propagateChange: any;\n  propagateTouch: any;\n\n  // source streams\n  @Changes('options') options$: Observable<any[]>;\n\n  // presentation streams\n  formattedOptions$: Observable<\n    { label: string; value: any; disabled: boolean }[]\n  >;\n\n  @ViewChild('inputElement', { read: ElementRef }) inputElement: ElementRef;\n\n  // Determines how the search is done.\n  @Input() searchFn: SearchFnSelect = (input: string, x: SearchOption) =>\n    x?.label?.toLowerCase().startsWith(input.toLowerCase());\n\n  nzSearchFn: NzFilterOptionType = (input: string, x: NzSelectItemInterface) =>\n    this.searchFn(input, { label: x.nzLabel as string, value: x.nzValue });\n\n  sofFocus(): void {\n    this.inputElement.nativeElement.getElementsByTagName('input')[0].focus();\n    this.changeDetectorRef.detectChanges();\n  }\n\n  ngOnInit(): void {\n    this.formattedOptions$ = this.options$.pipe(\n      map(options => options ?? []),\n      map(options =>\n        options.map(option => ({\n          label: this.selectorLabel(option),\n          value: this.selectorValue(option),\n          disabled: this.selectorDisabled ? this.selectorDisabled(option) : null\n        }))\n      )\n    );\n\n    // the reason why we're using valueChanges instead of fn ngModelChange\n    // is because:\n    // When we want to update the single-select without that the user\n    // did something we will trigger the fn writeValue. That fn\n    // will update the form value.\n    // When we update the value we're aware of the change of the value.\n    // So sometimes we don't want that valueChanges isn't triggered.\n    // that's possible by adding { emitEvent: false } to the patchValue\n    // but when you use the fn ngModelChange he will ignore the\n    // { emitEvent: false } option. So to use that we need to\n    // listen on the valueChanges events instead.\n    this.internalFormControl.valueChanges\n      .pipe(takeUntilDestroy(this))\n      .subscribe(value => {\n        if (!this.isDisabled) {\n          this.changeValue.emit(this.internalFormControl.value);\n\n          if (this.propagateChange) {\n            this.propagateChange(this.internalFormControl.value);\n          }\n        }\n      });\n  }\n\n  ngOnChanges(): void {}\n\n  ngOnDestroy(): void {\n    if (this.ngControl?.valueAccessor) {\n      // Every time a control is re-created the previous writeValue reference(s) is not cleaned up.\n      // So, over time, a lot of these references can be built up. This memory leak is a bug in Angular's implementation of ControlValueAccessor.\n      // We hide that problem by assigning an empty function to writeValue every time we destroy the control.\n      // An detailed explanation of the problem can be found here: https://github.com/angular/angular/pull/29335\n      // The bug issue for it: https://github.com/angular/angular/issues/20007\n      this.ngControl.valueAccessor.writeValue = () => {};\n    }\n  }\n\n  registerOnChange(fn: any): void {\n    this.propagateChange = fn;\n  }\n\n  registerOnTouched(fn: any): void {\n    this.propagateTouch = fn;\n  }\n\n  writeValue(value: any): void {\n    this.internalFormControl.setValue(value ?? [], { emitEvent: false });\n  }\n\n  onTouch(): void {\n    if (!this.isDisabled && this.propagateTouch) {\n      this.propagateTouch();\n    }\n  }\n\n  setDisabledState(value: boolean): void {\n    this.isDisabled = value;\n  }\n}\n","import { CommonModule } from '@angular/common';\nimport { NgModule } from '@angular/core';\nimport { FormsModule, ReactiveFormsModule } from '@angular/forms';\nimport { TranslateModule } from '@ngx-translate/core';\nimport { NzSelectModule } from 'ng-zorro-antd/select';\nimport { InputMultiSelectComponent } from './input-multi-select.component';\n\n@NgModule({\n  imports: [\n    CommonModule,\n    ReactiveFormsModule,\n    NzSelectModule,\n    FormsModule,\n    TranslateModule\n  ],\n  declarations: [InputMultiSelectComponent],\n  exports: [InputMultiSelectComponent]\n})\nexport class InputMultiSelectModule {}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"],"names":[],"mappings":"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"}